;   Copyright (c) Rich Hickey. All rights reserved.
;   The use and distribution terms for this software are covered by the
;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;   which can be found in the file epl-v10.html at the root of this distribution.
;   By using this software in any fashion, you are agreeing to be bound by
;   the terms of this license.
;   You must not remove this notice, or any other, from this software.

;;  Tests for the Clojure 'for' macro
;;
;;  by Chouser
;;  Created Dec 2008

(ns cljd.test-clojure.core-test
  (:use [cljd.test :only [deftest is testing are]]))

#_(deftest test-metadata
  (testing "Testing metadata"
    (is (= {"x" "y"} (meta ^{"x" "y"} [])))
    ))

(deftest test-fn-with-metadata
  (let [f (fn [x] (* x 2))
        m {:foo "bar"}
        mf (with-meta f m)]
    (testing "Testing functions with metadata"
      (is (nil? (meta f)))
      (is (fn? mf))
      (is (= 4 (mf 2)))
      (is (= 4 (apply mf [2])))
      (is (= (meta mf) m)))))

(deftest test-atoms-and-volatile
  (let [a (atom 0)]
    (testing "Testing basic atom operations"
      (is (= 0 (deref a)))
      (is (= 1 (swap! a inc)))
      (is (= false (compare-and-set! a 0 42)))
      (is (= true (compare-and-set! a 1 7)))
      (is (nil? (meta a)))
      (is (nil? (get-validator a)))))
  (let [a (atom 0)]
    (testing "Testing swap!"
      (is (= 1 (swap! a + 1)))
      (is (= 4 (swap! a + 1 2)))
      (is (= 10 (swap! a + 1 2 3)))
      (is (= 20 (swap! a + 1 2 3 4)))))
  (let [a (atom [1] :validator coll? :meta {:a 1})]
    (testing "Testing atom validators"
      (is (= (get-validator a) coll?))
      ;; TODO
      (is (thrown? Exception (reset! a 1)))
      (is (thrown? Exception (set-validator! a number?)))
      (is (some? (get-validator a)))
      (set-validator! a nil)
      (is (nil? (get-validator a)))
      (let [e1 (ex-info "" {})]
        (try
          (set-validator! a (fn [_] (throw e1)))
          (catch Object e2
            (is (identical? e1 e2)))))
      (is (= {:a 1} (meta a)))
      (alter-meta! a assoc :b 2)
      (is (= {:a 1 :b 2} (meta a)))))
  (let [v (volatile! 1)]
    (testing "Testing volatile"
      (is (volatile? v))
      (is (not (volatile? (atom 1))))
      (is (= 2 (vreset! v 2)))
      (is (= 3 (vswap! v inc)))
      (is (= 3 @v)))))

(deftest test-contains?
  (testing "Testing contains?"
    (is (contains? {:a 1 :b 2} :a))
    (is (not (contains? {:a 1 :b 2} :z)))
    (is (contains? [5 6 7] 1))
    (is (contains? [5 6 7] 2))
    (is (not (contains? [5 6 7] 3)))
    (is (contains? (to-array [5 6 7]) 1))
    (is (contains? (to-array [5 6 7]) 2))
    (is (not (contains? (to-array [5 6 7]) 3)))
    (is (not (contains? nil 42)))
    (is (contains? "f" 0))
    (is (not (contains? "f" 55))))


  (testing "Testing contains? with ILookup protocol"
    (let [ds (reify cljd.core/ILookup
               (-contains-key? [_ k] (= k :valid)))]
      (is (contains? ds :valid))
      (is (not (contains? ds :invalid))))))

(deftest test-in-operations
  (testing "Testing update-in"
    (is (= {:foo {:bar {:baz 1}}}
          (update-in {:foo {:bar {:baz 0}}} [:foo :bar :baz] inc)))
    (is (= {:foo 1 :bar 2 :baz 10}
          (update-in {:foo 1 :bar 2 :baz 3} [:baz] + 7)))
    (is (= [{:foo 1, :bar 2} {:foo 1, :bar 3}]
          (update-in [{:foo 1 :bar 2}, {:foo 1 :bar 2}] [1 :bar] inc)))
    (is (= [{:foo {:bar 2}} {:foo {:bar 3}}]
          (update-in [{:foo {:bar 2}}, {:foo {:bar 2}}] [1 :foo :bar] inc))))
  (testing "Testing assoc-in"
    (is (= {:foo {:bar {:baz 100}}}
          (assoc-in {:foo {:bar {:baz 0}}} [:foo :bar :baz] 100)))
    (is (= {:foo 1 :bar 2 :baz 100}
          (assoc-in {:foo 1 :bar 2 :baz 3} [:baz] 100)))
    (is (= [{:foo [{:bar 2} {:baz 3}]} {:foo [{:bar 2} {:baz 100}]}]
          (assoc-in [{:foo [{:bar 2} {:baz 3}]}, {:foo [{:bar 2} {:baz 3}]}]
            [1 :foo 1 :baz] 100)))
    (is (= [{:foo 1, :bar 2} {:foo 1, :bar 100}]
          (assoc-in [{:foo 1 :bar 2}, {:foo 1 :bar 2}] [1 :bar] 100))))
  (testing "Testing get-in"
    (is (= 1 (get-in {:foo 1 :bar 2} [:foo])))
    (is (= 2 (get-in {:foo {:bar 2}} [:foo :bar])))
    (is (= 1 (get-in [{:foo 1}, {:foo 2}] [0 :foo])))
    (is (= 4 (get-in [{:foo 1 :bar [{:baz 1}, {:buzz 2}]}, {:foo 3 :bar [{:baz 3}, {:buzz 4}]}]
               [1 :bar 1 :buzz])))))

#_(deftest test-transducers
  (testing "Testing transducers"
    (is (= (sequence (map inc) (array 1 2 3)) '(2 3 4)))
    (is (= (apply str (sequence (map #(.toUpperCase %)) "foo")) "FOO"))
    (is (== (hash [1 2 3]) (hash (sequence (map inc) (range 3)))))
    (is (= [1 2 3] (sequence (map inc) (range 3))))
    (is (= (sequence (map inc) (range 3)) [1 2 3]))
    (is (= (sequence (remove even?) (range 10)) '(1 3 5 7 9)))
    (is (= (sequence (take 5) (range 10))
          '(0 1 2 3 4)))
    (is (= (sequence (take-while #(< % 5)) (range 10))
          '(0 1 2 3 4)))
    (is (= (sequence (drop 5) (range 10))
          '(5 6 7 8 9)))
    (is (= (sequence (drop-while #(< % 5)) (range 10))
          '(5 6 7 8 9)))
    (is (= (sequence (take-nth 2) (range 10))
          '(0 2 4 6 8)))
    (is (= (sequence (replace {:foo :bar}) '(:foo 1 :foo 2))
          '(:bar 1 :bar 2)))
    (let [ret (into [] (map inc) (range 3))]
      (is (and (vector? ret) (= ret '(1 2 3)))))
    (let [ret (into [] (filter even?) (range 10))]
      (is (and (vector? ret) (= ret '(0 2 4 6 8)))))
    (is (= (map inc (sequence (map inc) (range 3)))
          '(2 3 4)))
    (is (= (sequence (dedupe) [1 1 2 2 3 3])
          '(1 2 3)))
    (is (= (mapcat reverse [[3 2 1 0] [6 5 4] [9 8 7]])
          (range 10)))
    (is (= (sequence (mapcat reverse) [[3 2 1 0] [6 5 4] [9 8 7]])
          (range 10)))
    (is (= (seq (eduction (map inc) [1 2 3])) '(2 3 4)))
    (is (= (seq (eduction (map inc) (map inc) [1 2 3])) '(3 4 5)))
    (is (= (sequence (partition-by #{:split}) [1 2 3 :split 4 5 6])
          '([1 2 3] [:split] [4 5 6])))
    (is (= (sequence (partition-all 3) '(1 2 3 4 5))
          '([1 2 3] [4 5])))
    (is (= (sequence (keep identity) [1 nil 2 nil 3])
          '(1 2 3)))
    (is (= (keep-indexed identity [:foo nil :bar nil :baz])
          (sequence (keep-indexed identity) [:foo nil :bar nil :baz])))
    (let [xform (comp (map inc)
                  (filter even?)
                  (dedupe)
                  (mapcat range)
                  (partition-all 3)
                  (partition-by #(< (apply + %) 7))
                  (mapcat flatten)
                  (random-sample 1.0)
                  (take-nth 1)
                  (keep #(when (odd? %) (* % %)))
                  (keep-indexed #(when (even? %1) (* %1 %2)))
                  (replace {2 "two" 6 "six" 18 "eighteen"})
                  (take 11)
                  (take-while #(not= 300 %))
                  (drop 1)
                  (drop-while string?)
                  (remove string?))
          data (vec (interleave (range 18) (range 20)))]
      (is (= (sequence xform data) '(36 200 10))))
    (let [xf (map #(+ %1 %2))]
      (is (= (sequence xf [0 0] [1 2]) [1 2])))
    (is (= (-> (sequence (map inc) [1 2 3])
             (with-meta {:a 1})
             meta) {:a 1}))
    (let [xf (fn [rf]
               (fn
                 ([] (rf))
                 ([result] (rf result :foo))
                 ([result input] (rf result input))))]
      (is (= (sequence xf [1 2 3]) [1 2 3 :foo]))))
  (testing "CLJS-2258"
    (is (= ["1"] (sequence (map str) (eduction [1]))))))

(deftest test-obj-equiv
  (testing "Object equiv method"
    (is (-equiv :foo :foo))
    (is (-equiv 'foo 'foo))
    (is (-equiv {:foo 1 :bar 2} {:foo 1 :bar 2}))
    (is (-equiv [1 2 3] [1 2 3]))
    (is (-equiv '(1 2 3) '(1 2 3)))
    (is (-equiv (map inc [1 2 3]) (map inc [1 2 3])))
    (is (-equiv #{:cat :dog :bird} #{:cat :dog :bird}))))

(def constantly-nil (constantly nil))

(deftest some->test
  (is (nil? (some-> nil)))
  (is (= 0 (some-> 0)))
  (is (= -1 (some-> 1 (- 2))))
  (is (nil? (some-> 1 constantly-nil (- 2)))))

(deftest some->>test
  (is (nil? (some->> nil)))
  (is (= 0 (some->> 0)))
  (is (= 1 (some->> 1 (- 2))))
  (is (nil? (some->> 1 constantly-nil (- 2)))))

(deftest cond->test
  (is (= 0 (cond-> 0)))
  (is (= -1 (cond-> 0 true inc true (- 2))))
  (is (= 0 (cond-> 0 false inc)))
  (is (= -1 (cond-> 1 true (- 2) false inc))))

(deftest cond->>test
  (is (= 0 (cond->> 0)))
  (is (= 1 (cond->> 0 true inc true (- 2))))
  (is (= 0 (cond->> 0 false inc)))
  (is (= 1 (cond->> 1 true (- 2) false inc))))

(deftest as->test
  (is (= 0 (as-> 0 x)))
  (is (= 1 (as-> 0 x (inc x))))
  (is (= 2 (as-> [0 1] x
             (map inc x)
             (reverse x)
             (first x)))))

(deftest threading-loop-recur
  (is (nil? (loop []
              (as-> 0 x
                (when-not (zero? x)
                  (recur))))))
  (is (nil? (loop [x nil] (some-> x recur))))
  (is (nil? (loop [x nil] (some->> x recur))))
  (is (= 0 (loop [x 0] (cond-> x false recur))))
  (is (= 0 (loop [x 0] (cond->> x false recur)))))

(deftest aget-test
  (is (= 11 (aget #dart [10 11 12] 1)))
  (is (= 11 (apply aget [#dart [10 11 12] 1])))
  (is (= 3 (aget #dart [1 2 #dart [3 4]] 2 0)))
  (is (= 3 (apply aget [#dart [1 2 #dart [3 4]] 2 0]))))

(deftest aset-test
  (let [array #dart [10 11 12]]
    (is (= 13 (aset array 1 13)))
    (is (= 13 (aget array 1))))
  (let [array #dart [10 11 12]]
    (is (= 13 (apply aset [array 1 13])))
    (is (= 13 (aget array 1))))
  (let [array #dart [1 2 #dart [3 4]]]
    (is (= 13 (aset array 2 0 13)))
    (is (= 13 (aget array 2 0))))
  (let [array #dart [1 2 #dart [3 4]]]
    (is (= 13 (apply aset [array 2 0 13])))
    (is (= 13 (aget array 2 0)))))

(deftest memfn-test
  (let [substr (memfn substring start length)]
    (is (= "c" (substr "abcdefg" 2 3))))
  (let [trim (memfn trim)]
    (is (= ["abc" "def"] (map trim ["   abc   " "  def   "])))))

(deftest test-383
  (testing "Testing CLJS-383"
    ;; TODO : move up `let` when tests are reliable
    (let [f1 (fn f1 ([] 0) ([a] 1) ([a b] 2) ([a b c & more] 3))
          f2 (fn f2 ([x] :foo) ([x y & more] (apply f1 y more)))]
      (is (= 1 (f2 1 2))))
    (let [f (fn ([]) ([a & more] more))]
      (is (nil? (f :foo))))))

(deftest test-513
  (testing "Testing CLJS-513"
    (let [sentinel (Object.)]
      (is (identical? sentinel (try (throw "ee") (catch Object _ sentinel)))))))

(defprotocol IFoo (foo [this]))

(deftest test-reify-meta
  (is (= (meta (with-meta (reify IFoo (foo [this] :foo)) {:foo :bar}))
        {:foo :bar})))

(deftest test-401-411
  (is (= "original" (let [x "original"
                          oce (fn [] x)
                          x "overwritten"]
                      (oce)))))

(deftest test-letfn-shadowing
  (letfn [(x [] "original")
          (y [] (x))]
    (let [x (fn [] "overwritten")]
      (is (= "original" (y))))))

(deftest test-compare-fn
  (testing "Testing compare default function"
    (is (compare 'a 'b))
    (is (compare 'a 'a))
    (is (compare :a :a))
    (is (compare :a :b))
    (is (compare :a/b :a/b))
    (is (compare [:a :b] [:a :b]))
    (is (compare [:a :b] [:a :c]))
    (is (compare [:a :b] (first {:a :b})))
    (is (compare (first {:a :b}) (first {:a :b}))))

  (testing "Testing sort function"
    (is (= '(-100 1 2 3 100) (sort [3 2 1 100 -100])))
    (is (= '(:a :b :c) (sort [:a :c :b])))
    (is (= '([:a :b] [:c :d]) (sort {:c :d :a :b})))
    (is (= '(3 2 1) (sort (fn [x y] (if (< x y) 1 -1)) [1 2 3])))))

(deftest test-kv-reduce
  (letfn [(kvr-test [data expect]
            (and
              (= :reduced
                (reduce-kv
                  (fn [_ _ _] (reduced :reduced))
                  [] data))
              (= (sort expect)
                (sort
                  (reduce-kv
                    (fn [r k v] (-> r (conj [k v])))
                    [] data)))))]
    (testing "Testing IKVReduce"
      (doseq [[data expect] [[(hash-map :k0 :v0 :k1 :v1) [[:k0 :v0] [:k1 :v1]]]
                             [[:v0 :v1] [[0 :v0] [1 :v1]]]]]
        (is (kvr-test data expect)))
      (is (= {:init :val} (reduce-kv assoc {:init :val} nil))))))

(deftest test-2067
  (is (= 0 (reduce-kv
             (fn [x k _]
               (when (zero? k)
                 (reduced k)))
             nil (zipmap (range 17) (repeat 0))))))

(deftest test-435
  (is (= (assoc {} 154618822656 1 261993005056 1)
        {154618822656 1 261993005056 1})))

(deftest test-458
  (is (= (get-in {:a {:b 1}} [:a :b :c] :nothing-there)
        :nothing-there)))

(deftest test-464
  (is (nil? (get-in {:foo {:bar 2}} [:foo :bar :baz]))))

(deftest test-symbol-meta
  (is (= (meta (with-meta 'foo {:tag 'int})) {:tag 'int}))
  #_#_#_(is (= (meta (quote ^{:bar true} foo)) {:bar true}))
  (is (= (meta (quote ^:bar foo)) {:bar true}))
  (is (= (meta (first '[^:bar x])) {:bar true})))

(deftest test-467
  (is (= (reduce-kv + 0 (apply hash-map (range 1000)))
        (reduce + (range 1000)))))

(deftest test-493
  (is (nil? (get 42 :anything)))
  (is (= (get 42 :anything :not-found) :not-found))
  (is (nil? (first (map get [42] [:anything]))))
  (is (= (first (map get [42] [:anything] [:not-found])) :not-found)))

(deftest test-481
  (let [fs (atom [])]
    (doseq [x (range 4)
            :let [y (inc x)
                  f (fn [] y)]]
      (swap! fs conj f))
    (is (= (map #(%) @fs) '(1 2 3 4)))))

(deftest test-518
  (is (nil? (:test "test"))))

(deftest test-582
  (is (= #{1 2} (set [1 2 2])))
  (is (= #{1 2} (hash-set 1 2 2)))
  (is (= #{1 2} (apply hash-set [1 2 2]))))

(deftest test-585
  (is (= (last (map identity (into [] (range 32)))) 31))
  (is (= (into #{} (range 32))
        (set (map identity (into [] (range 32)))))))

(def foo580 {:a (fn []) :b (fn [] (foo580 :a))})

(deftest test-580
  (is (nil? (((:b foo580))))))

(deftest test-587
  (is (== (first (filter #(== % 9999) (range))) 9999)))

(deftest test-604
  (is (= () (concat nil [])))
  (is (= () (concat [] []))))

(deftest test-600
  (is (= "foobar" (apply str (concat "foo" "bar")))))

(deftest test-608
  (is (= '("") (re-seq #"\s*" ""))))
