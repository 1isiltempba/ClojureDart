;   Copyright (c) Rich Hickey. All rights reserved.
;   The use and distribution terms for this software are covered by the
;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;   which can be found in the file epl-v10.html at the root of this distribution.
;   By using this software in any fashion, you are agreeing to be bound by
;   the terms of this license.
;   You must not remove this notice, or any other, from this software.

;;  Tests for the Clojure 'for' macro
;;
;;  by Chouser
;;  Created Dec 2008

(ns cljd.test-clojure.core-test
  (:use [cljd.test :only [deftest is testing are]]))

#_(deftest test-metadata
  (testing "Testing metadata"
    (is (= {"x" "y"} (meta ^{"x" "y"} [])))
    ))

(deftest test-fn-with-metadata
  (let [f (fn [x] (* x 2))
        m {:foo "bar"}
        mf (with-meta f m)]
    (testing "Testing functions with metadata"
      (is (nil? (meta f)))
      (is (fn? mf))
      (is (= 4 (mf 2)))
      (is (= 4 (apply mf [2])))
      (is (= (meta mf) m)))))

(deftest test-atoms-and-volatile
  (let [a (atom 0)]
    (testing "Testing basic atom operations"
      (is (= 0 (deref a)))
      (is (= 1 (swap! a inc)))
      (is (= false (compare-and-set! a 0 42)))
      (is (= true (compare-and-set! a 1 7)))
      (is (nil? (meta a)))
      (is (nil? (get-validator a)))))
  (let [a (atom 0)]
    (testing "Testing swap!"
      (is (= 1 (swap! a + 1)))
      (is (= 4 (swap! a + 1 2)))
      (is (= 10 (swap! a + 1 2 3)))
      (is (= 20 (swap! a + 1 2 3 4)))))
  (let [a (atom [1] :validator coll? :meta {:a 1})]
    (testing "Testing atom validators"
      (is (= (get-validator a) coll?))
      ;; TODO
      (is (thrown? Exception (reset! a 1)))
      (is (thrown? Exception (set-validator! a number?)))
      (is (some? (get-validator a)))
      (set-validator! a nil)
      (is (nil? (get-validator a)))
      (let [e1 (ex-info "" {})]
        (try
          (set-validator! a (fn [_] (throw e1)))
          (catch Object e2
            (is (identical? e1 e2)))))
      (is (= {:a 1} (meta a)))
      (alter-meta! a assoc :b 2)
      (is (= {:a 1 :b 2} (meta a)))))
  (let [v (volatile! 1)]
    (testing "Testing volatile"
      (is (volatile? v))
      (is (not (volatile? (atom 1))))
      (is (= 2 (vreset! v 2)))
      (is (= 3 (vswap! v inc)))
      (is (= 3 @v)))))

(deftest test-contains?
  (testing "Testing contains?"
    (is (contains? {:a 1 :b 2} :a))
    (is (not (contains? {:a 1 :b 2} :z)))
    (is (contains? [5 6 7] 1))
    (is (contains? [5 6 7] 2))
    (is (not (contains? [5 6 7] 3)))
    (is (contains? (to-array [5 6 7]) 1))
    (is (contains? (to-array [5 6 7]) 2))
    (is (not (contains? (to-array [5 6 7]) 3)))
    (is (not (contains? nil 42)))
    (is (contains? "f" 0))
    (is (not (contains? "f" 55))))


  (testing "Testing contains? with ILookup protocol"
    (let [ds (reify cljd.core/ILookup
               (-contains-key? [_ k] (= k :valid)))]
      (is (contains? ds :valid))
      (is (not (contains? ds :invalid))))))

(deftest test-in-operations
  (testing "Testing update-in"
    (is (= {:foo {:bar {:baz 1}}}
          (update-in {:foo {:bar {:baz 0}}} [:foo :bar :baz] inc)))
    (is (= {:foo 1 :bar 2 :baz 10}
          (update-in {:foo 1 :bar 2 :baz 3} [:baz] + 7)))
    (is (= [{:foo 1, :bar 2} {:foo 1, :bar 3}]
          (update-in [{:foo 1 :bar 2}, {:foo 1 :bar 2}] [1 :bar] inc)))
    (is (= [{:foo {:bar 2}} {:foo {:bar 3}}]
          (update-in [{:foo {:bar 2}}, {:foo {:bar 2}}] [1 :foo :bar] inc))))
  (testing "Testing assoc-in"
    (is (= {:foo {:bar {:baz 100}}}
          (assoc-in {:foo {:bar {:baz 0}}} [:foo :bar :baz] 100)))
    (is (= {:foo 1 :bar 2 :baz 100}
          (assoc-in {:foo 1 :bar 2 :baz 3} [:baz] 100)))
    (is (= [{:foo [{:bar 2} {:baz 3}]} {:foo [{:bar 2} {:baz 100}]}]
          (assoc-in [{:foo [{:bar 2} {:baz 3}]}, {:foo [{:bar 2} {:baz 3}]}]
            [1 :foo 1 :baz] 100)))
    (is (= [{:foo 1, :bar 2} {:foo 1, :bar 100}]
          (assoc-in [{:foo 1 :bar 2}, {:foo 1 :bar 2}] [1 :bar] 100))))
  (testing "Testing get-in"
    (is (= 1 (get-in {:foo 1 :bar 2} [:foo])))
    (is (= 2 (get-in {:foo {:bar 2}} [:foo :bar])))
    (is (= 1 (get-in [{:foo 1}, {:foo 2}] [0 :foo])))
    (is (= 4 (get-in [{:foo 1 :bar [{:baz 1}, {:buzz 2}]}, {:foo 3 :bar [{:baz 3}, {:buzz 4}]}]
               [1 :bar 1 :buzz])))))

#_(deftest test-transducers
  (testing "Testing transducers"
    (is (= (sequence (map inc) (array 1 2 3)) '(2 3 4)))
    (is (= (apply str (sequence (map #(.toUpperCase %)) "foo")) "FOO"))
    (is (== (hash [1 2 3]) (hash (sequence (map inc) (range 3)))))
    (is (= [1 2 3] (sequence (map inc) (range 3))))
    (is (= (sequence (map inc) (range 3)) [1 2 3]))
    (is (= (sequence (remove even?) (range 10)) '(1 3 5 7 9)))
    (is (= (sequence (take 5) (range 10))
          '(0 1 2 3 4)))
    (is (= (sequence (take-while #(< % 5)) (range 10))
          '(0 1 2 3 4)))
    (is (= (sequence (drop 5) (range 10))
          '(5 6 7 8 9)))
    (is (= (sequence (drop-while #(< % 5)) (range 10))
          '(5 6 7 8 9)))
    (is (= (sequence (take-nth 2) (range 10))
          '(0 2 4 6 8)))
    (is (= (sequence (replace {:foo :bar}) '(:foo 1 :foo 2))
          '(:bar 1 :bar 2)))
    (let [ret (into [] (map inc) (range 3))]
      (is (and (vector? ret) (= ret '(1 2 3)))))
    (let [ret (into [] (filter even?) (range 10))]
      (is (and (vector? ret) (= ret '(0 2 4 6 8)))))
    (is (= (map inc (sequence (map inc) (range 3)))
          '(2 3 4)))
    (is (= (sequence (dedupe) [1 1 2 2 3 3])
          '(1 2 3)))
    (is (= (mapcat reverse [[3 2 1 0] [6 5 4] [9 8 7]])
          (range 10)))
    (is (= (sequence (mapcat reverse) [[3 2 1 0] [6 5 4] [9 8 7]])
          (range 10)))
    (is (= (seq (eduction (map inc) [1 2 3])) '(2 3 4)))
    (is (= (seq (eduction (map inc) (map inc) [1 2 3])) '(3 4 5)))
    (is (= (sequence (partition-by #{:split}) [1 2 3 :split 4 5 6])
          '([1 2 3] [:split] [4 5 6])))
    (is (= (sequence (partition-all 3) '(1 2 3 4 5))
          '([1 2 3] [4 5])))
    (is (= (sequence (keep identity) [1 nil 2 nil 3])
          '(1 2 3)))
    (is (= (keep-indexed identity [:foo nil :bar nil :baz])
          (sequence (keep-indexed identity) [:foo nil :bar nil :baz])))
    (let [xform (comp (map inc)
                  (filter even?)
                  (dedupe)
                  (mapcat range)
                  (partition-all 3)
                  (partition-by #(< (apply + %) 7))
                  (mapcat flatten)
                  (random-sample 1.0)
                  (take-nth 1)
                  (keep #(when (odd? %) (* % %)))
                  (keep-indexed #(when (even? %1) (* %1 %2)))
                  (replace {2 "two" 6 "six" 18 "eighteen"})
                  (take 11)
                  (take-while #(not= 300 %))
                  (drop 1)
                  (drop-while string?)
                  (remove string?))
          data (vec (interleave (range 18) (range 20)))]
      (is (= (sequence xform data) '(36 200 10))))
    (let [xf (map #(+ %1 %2))]
      (is (= (sequence xf [0 0] [1 2]) [1 2])))
    (is (= (-> (sequence (map inc) [1 2 3])
             (with-meta {:a 1})
             meta) {:a 1}))
    (let [xf (fn [rf]
               (fn
                 ([] (rf))
                 ([result] (rf result :foo))
                 ([result input] (rf result input))))]
      (is (= (sequence xf [1 2 3]) [1 2 3 :foo]))))
  (testing "CLJS-2258"
    (is (= ["1"] (sequence (map str) (eduction [1]))))))

(deftest test-obj-equiv
  (testing "Object equiv method"
    (is (-equiv :foo :foo))
    (is (-equiv 'foo 'foo))
    (is (-equiv {:foo 1 :bar 2} {:foo 1 :bar 2}))
    (is (-equiv [1 2 3] [1 2 3]))
    (is (-equiv '(1 2 3) '(1 2 3)))
    (is (-equiv (map inc [1 2 3]) (map inc [1 2 3])))
    (is (-equiv #{:cat :dog :bird} #{:cat :dog :bird}))))

(def constantly-nil (constantly nil))

(deftest some->test
  (is (nil? (some-> nil)))
  (is (= 0 (some-> 0)))
  (is (= -1 (some-> 1 (- 2))))
  (is (nil? (some-> 1 constantly-nil (- 2)))))

(deftest some->>test
  (is (nil? (some->> nil)))
  (is (= 0 (some->> 0)))
  (is (= 1 (some->> 1 (- 2))))
  (is (nil? (some->> 1 constantly-nil (- 2)))))

(deftest cond->test
  (is (= 0 (cond-> 0)))
  (is (= -1 (cond-> 0 true inc true (- 2))))
  (is (= 0 (cond-> 0 false inc)))
  (is (= -1 (cond-> 1 true (- 2) false inc))))

(deftest cond->>test
  (is (= 0 (cond->> 0)))
  (is (= 1 (cond->> 0 true inc true (- 2))))
  (is (= 0 (cond->> 0 false inc)))
  (is (= 1 (cond->> 1 true (- 2) false inc))))

(deftest as->test
  (is (= 0 (as-> 0 x)))
  (is (= 1 (as-> 0 x (inc x))))
  (is (= 2 (as-> [0 1] x
             (map inc x)
             (reverse x)
             (first x)))))

(deftest threading-loop-recur
  (is (nil? (loop []
              (as-> 0 x
                (when-not (zero? x)
                  (recur))))))
  (is (nil? (loop [x nil] (some-> x recur))))
  (is (nil? (loop [x nil] (some->> x recur))))
  (is (= 0 (loop [x 0] (cond-> x false recur))))
  (is (= 0 (loop [x 0] (cond->> x false recur)))))

(deftest aget-test
  (is (= 11 (aget #dart [10 11 12] 1)))
  (is (= 11 (apply aget [#dart [10 11 12] 1])))
  (is (= 3 (aget #dart [1 2 #dart [3 4]] 2 0)))
  (is (= 3 (apply aget [#dart [1 2 #dart [3 4]] 2 0]))))

(deftest aset-test
  (let [array #dart [10 11 12]]
    (is (= 13 (aset array 1 13)))
    (is (= 13 (aget array 1))))
  (let [array #dart [10 11 12]]
    (is (= 13 (apply aset [array 1 13])))
    (is (= 13 (aget array 1))))
  (let [array #dart [1 2 #dart [3 4]]]
    (is (= 13 (aset array 2 0 13)))
    (is (= 13 (aget array 2 0))))
  (let [array #dart [1 2 #dart [3 4]]]
    (is (= 13 (apply aset [array 2 0 13])))
    (is (= 13 (aget array 2 0)))))

(deftest memfn-test
  (let [substr (memfn substring start length)]
    (is (= "c" (substr "abcdefg" 2 3))))
  (let [trim (memfn trim)]
    (is (= ["abc" "def"] (map trim ["   abc   " "  def   "])))))

(deftest test-383
  (testing "Testing CLJS-383"
    ;; TODO : move up `let` when tests are reliable
    (let [f1 (fn f1 ([] 0) ([a] 1) ([a b] 2) ([a b c & more] 3))
          f2 (fn f2 ([x] :foo) ([x y & more] (apply f1 y more)))]
      (is (= 1 (f2 1 2))))
    (let [f (fn ([]) ([a & more] more))]
      (is (nil? (f :foo))))))

(deftest test-513
  (testing "Testing CLJS-513"
    (let [sentinel (Object.)]
      (is (identical? sentinel (try (throw "ee") (catch Object _ sentinel)))))))

(defprotocol IFoo (foo [this]))

(deftest test-reify-meta
  (is (= (meta (with-meta (reify IFoo (foo [this] :foo)) {:foo :bar}))
        {:foo :bar})))

(deftest test-401-411
  (is (= "original" (let [x "original"
                          oce (fn [] x)
                          x "overwritten"]
                      (oce)))))

(deftest test-letfn-shadowing
  (letfn [(x [] "original")
          (y [] (x))]
    (let [x (fn [] "overwritten")]
      (is (= "original" (y))))))

(deftest test-compare-fn
  (testing "Testing compare default function"
    (is (compare 'a 'b))
    (is (compare 'a 'a))
    (is (compare :a :a))
    (is (compare :a :b))
    (is (compare :a/b :a/b))
    (is (compare [:a :b] [:a :b]))
    (is (compare [:a :b] [:a :c]))
    (is (compare [:a :b] (first {:a :b})))
    (is (compare (first {:a :b}) (first {:a :b}))))

  (testing "Testing sort function"
    (is (= '(-100 1 2 3 100) (sort [3 2 1 100 -100])))
    (is (= '(:a :b :c) (sort [:a :c :b])))
    (is (= '([:a :b] [:c :d]) (sort {:c :d :a :b})))
    (is (= '(3 2 1) (sort (fn [x y] (if (< x y) 1 -1)) [1 2 3])))))

(deftest test-kv-reduce
  (letfn [(kvr-test [data expect]
            (and
              (= :reduced
                (reduce-kv
                  (fn [_ _ _] (reduced :reduced))
                  [] data))
              (= (sort expect)
                (sort
                  (reduce-kv
                    (fn [r k v] (-> r (conj [k v])))
                    [] data)))))]
    (testing "Testing IKVReduce"
      (doseq [[data expect] [[(hash-map :k0 :v0 :k1 :v1) [[:k0 :v0] [:k1 :v1]]]
                             [[:v0 :v1] [[0 :v0] [1 :v1]]]]]
        (is (kvr-test data expect)))
      (is (= {:init :val} (reduce-kv assoc {:init :val} nil))))))

(deftest test-2067
  (is (= 0 (reduce-kv
             (fn [x k _]
               (when (zero? k)
                 (reduced k)))
             nil (zipmap (range 17) (repeat 0))))))

(deftest test-435
  (is (= (assoc {} 154618822656 1 261993005056 1)
        {154618822656 1 261993005056 1})))

(deftest test-458
  (is (= (get-in {:a {:b 1}} [:a :b :c] :nothing-there)
        :nothing-there)))

(deftest test-464
  (is (nil? (get-in {:foo {:bar 2}} [:foo :bar :baz]))))

(deftest test-symbol-meta
  (is (= (meta (with-meta 'foo {:tag 'int})) {:tag 'int}))
  #_#_#_(is (= (meta (quote ^{:bar true} foo)) {:bar true}))
  (is (= (meta (quote ^:bar foo)) {:bar true}))
  (is (= (meta (first '[^:bar x])) {:bar true})))

(deftest test-467
  (is (= (reduce-kv + 0 (apply hash-map (range 1000)))
        (reduce + (range 1000)))))

(deftest test-493
  (is (nil? (get 42 :anything)))
  (is (= (get 42 :anything :not-found) :not-found))
  (is (nil? (first (map get [42] [:anything]))))
  (is (= (first (map get [42] [:anything] [:not-found])) :not-found)))

(deftest test-481
  (let [fs (atom [])]
    (doseq [x (range 4)
            :let [y (inc x)
                  f (fn [] y)]]
      (swap! fs conj f))
    (is (= (map #(%) @fs) '(1 2 3 4)))))

(deftest test-518
  (is (nil? (:test "test"))))

(deftest test-582
  (is (= #{1 2} (set [1 2 2])))
  (is (= #{1 2} (hash-set 1 2 2)))
  (is (= #{1 2} (apply hash-set [1 2 2]))))

(deftest test-585
  (is (= (last (map identity (into [] (range 32)))) 31))
  (is (= (into #{} (range 32))
        (set (map identity (into [] (range 32)))))))

(def foo580 {:a (fn []) :b (fn [] (foo580 :a))})

(deftest test-580
  (is (nil? (((:b foo580))))))

(deftest test-587
  (is (== (first (filter #(== % 9999) (range))) 9999)))

(deftest test-604
  (is (= () (concat nil [])))
  (is (= () (concat [] []))))

(deftest test-600
  (is (= "foobar" (apply str (concat "foo" "bar")))))

(deftest test-608
  (is (= '("") (re-seq #"\s*" ""))))

(deftype KeywordTest []
  cljd.core/ILookup
  (-lookup [o k] :nothing)
  (-lookup [o k not-found] not-found))

(deftest tset-638
  (is (= (:a (KeywordTest.)) :nothing)))

(deftest test-648
  (let [a (reify cljd.core/IHash (-hash [_] 42))
        b (reify cljd.core/IHash (-hash [_] 42))
        s (set (range 128))]
    (testing "Testing CLJS-648 (CLJ-1285)"
      (is (= (-> (conj s a b) transient (disj! a) persistent! (conj a))
            (-> (conj s a b) transient (disj! a) persistent! (conj a)))))))

(deftest test-660
  (testing "Testing CLJS-660, namespace handling"
    (is (= (-> 'a.b keyword ((juxt namespace name))) [nil "a.b"]))
    (is (= (-> 'a.b/c keyword ((juxt namespace name))) ["a.b" "c"]))
    (is (= (-> "a.b" keyword ((juxt namespace name))) [nil "a.b"]))
    (is (= (-> "a.b/c" keyword ((juxt namespace name))) ["a.b" "c"]))
    (is (= (-> "/b/c/d" keyword ((juxt namespace name))) ["" "b/c/d"]))))

(deftest test-663
  (testing "Testing CLJS-663, invalid keywords"
    (is (= (keyword 123) nil))
    (is (= (keyword (.now dart:core/DateTime)) nil))))

(def some-x 1)
(def some-y 1)

(deftest test-583
  (is (= (count #{some-x some-y}) 1)))

(deftest test-584
  (is (= (count {some-x :foo some-y :bar}) 1)))

(deftest test-725
  (testing "Testing CLJS-725, drop"
    (is (= (apply vector (drop-while (partial = 1) [1 2 3])) [2 3]))
    (is (= (apply list (drop-while (partial = 1) [1 2 3])) '(2 3)))
    (is (= (set (drop 1 #dart [1 2 3])) #{2 3}))))

(deftest test-724
  (is (nil? (first (rest (rest (rest (range 3))))))))

(deftest test-767
  (testing "Testing CLJS-767, invalid assoc"
    (doseq [n [nil "-1" "" "0" "1" false true (Object.)]]
      (is (= :fail (try (assoc [1 2] n 4)
                        (catch Object e :fail))))
      (is (= :fail (try (assoc (subvec [1 2 3] 2) n 4)
                        (catch Object e :fail))))
      (is (= :fail (try (assoc (range 1 3) n 4)
                        (catch Object e :fail)))))))

(deftest test-768
  (testing "Testing CLJS-768, invalid assoc!"
    (doseq [n [nil "-1" "" "0" "1" false true (Object.)]]
      (is (= :fail (try (assoc! (transient [1 2]) n 4)
                        (catch Object e :fail)))))))

(deftest test-728
  (testing "Testing CLJS-728, lookup with default"
    (doseq [n [nil "-1" "" "0" "1" false true (Object.)]]
      (is (nil? (get [1 2] n)))
      (is (= :fail (try (nth [1 2] n) (catch Object e :fail))))
      (is (= 4 (get [1 2] n 4)))
      (is (= :fail (try (nth [1 2] n 4) (catch Object e :fail))))

      (is (nil? (get (subvec [1 2] 1) n)))
      (is (= :fail (try (nth (subvec [1 2] 1) n) (catch Object e :fail))))
      (is (= 4 (get (subvec [1 2] 1) n 4)))
      (is (= :fail (try (nth (subvec [1 2] 1) n 4) (catch Object e :fail))))

      (is (nil? (get (transient [1 2]) n)))
      (is (= :fail (try (nth (transient [1 2]) n) (catch Object e :fail))))
      (is (= 4 (get (transient [1 2]) n 4)))
      (is (= :fail (try (nth (transient [1 2]) n 4) (catch Object e :fail))))

      (is (nil? (get (range 1 3) n)))
      (is (= :fail (try (nth (range 1 3) n) (catch Object e :fail))))
      (is (= 4 (get (range 1 3) n 4)))
      (is (= :fail (try (nth (range 1 3) n 4) (catch Object e :fail)))))))

(deftest subvec-tests
  (testing "Testing subvec works as expected"
    (is (= (subvec [0 1] 1) [1]))
    (is (= (subvec [0 1] 0 1) [0]))
    (is (= (subvec [0 1] 2) []))
    (is (= (subvec [0 1] 1 1) []))

    (is (= (conj (subvec [0 1] 1 1) 1) [1]))
    (is (= ((subvec [0 1] 1) 0) 1))

    (is (= (nth (subvec [0 1 2 3 4] 2) 0) 2))
    (is (= (nth (subvec [0 1 2 3 4] 2) 1000 :default) :default))

    (is (= (subvec (first {0 1}) 1) [1]))
    (is (= (subvec (first {0 1}) 0) [0 1]))
    (is (= (subvec (first {0 1}) 2) []))
    (is (= (subvec (first {0 1}) 1 1) []))))

(deftest test-cljs-1845
  (let [sv (subvec [0 1 2 3 4 5 7 8 9] 2 6)]
    (is (= [2 3 4 5] sv))
    (is (= [2 3 0 5] (assoc sv 2 0)))
    (is (= [2 3 4 0] (assoc sv 3 0)))
    (is (= [2 3 4 5 0] (assoc sv 4 0)))
    (is (thrown? Error (assoc sv 5 0)))
    (is (thrown? Error (assoc sv -1 0)))))

(deftest test-cljs-2021
  (let [check-if-throws #(try (%) (catch Object e :fail))]
    (is (= :fail (check-if-throws #(subvec nil 0 0))))
    (is (= :fail (check-if-throws #(subvec {:foo :bar} 0 1))))
    (is (= :fail (check-if-throws #(subvec '(:foo) 0 1))))
    (is (= :fail (check-if-throws #(subvec #{:foo} 0 1))))))

(deftest test-cljs-1685
  (testing "nil start or end param throws error"
    (is (= :fail (try (subvec nil nil)
                      (catch Error e :fail))))
    (is (= :fail (try (subvec nil 1 nil)
                      (catch Error e :fail))))))

(deftest test-cljs-3092
  (is (nil? (peek (subvec [] 0))))
  (is (nil? (peek (subvec [1] 1))))
  (is (nil? (peek (subvec [1 2] 0 0))))
  (is (nil? (peek (subvec [1 2] 1 1))))
  (is (nil? (peek (subvec [1 2] 2 2)))))

(deftest test-cljs-3093
  (is (thrown-with-msg? ArgumentError #"Index out of bounds" (subvec [1 2 3 4] -1)))
  (is (= [1 2 3 4] (subvec [1 2 3 4] -0.9)))
  (is (thrown-with-msg? ArgumentError #"Index out of bounds" (subvec [1 2 3 4] 2 1)))
  (is (= [] (subvec [1 2 3 4] 1.7 1.3)))
  (is (thrown-with-msg? ArgumentError #"Index out of bounds" (subvec [1 2 3 4] 0 5)))
  (is (= [1 2 3 4] (subvec [1 2 3 4] 0 4.9))))

(deftest test-cljs-3306
  (let [sv (subvec [0 1 2 3 4] 2 4)]
    (is (true?  (contains? sv 0)))
    (is (false? (contains? sv 0.5)))
    (is (true?  (contains? sv 1)))
    (is (false? (contains? sv 1.5)))
    (is (false? (contains? sv :kw))))
  (let [sv (subvec [0 1 2 3 4] 2 2)]
    (is (false? (contains? sv 0)))))

(deftype MapWithNoIKVReduce [backing-map]
  cljd.core/IMap
  (-dissoc [_ _] nil)

  cljd.core/ISeqable
  (-seq [_] (seq backing-map)))

(deftest test-cljs-2083
  (testing "maps which do not implement IKVReduce can be compared"
    (is (true?  (-equiv-map (MapWithNoIKVReduce. {:a 1 :b 2 :c 3}) {:a 1 :b 2 :c 3})))
    (is (false? (-equiv-map (MapWithNoIKVReduce. {:a 1 :b 2 :c 3}) {:a 1 :b 2 :c 4})))))

(deftest test-cljs-2113
  (is (thrown? ArgumentError (nth (range 2) -2)))
  (is (thrown? ArgumentError (nth (range 2 1 0) -2)))
  (is (= ::not-found (nth (range 2) -2 ::not-found)))
  (is (= ::not-found (nth (range 2 1 0) -2 ::not-found))))

(deftype Partial [f args]
  cljd.core/IFn
  (-invoke [this a]
    (apply (apply partial f args) [a])))

(deftest test-cljs-2133
  (testing "Invalid variadic IFn implementation should work"
    (let [p (Partial. + [1])]
      (p 2))))

(def true-2267 true)
(def false-2267 false)
(def nil-2267 nil)
(def empty-string-2267 "")
(def non-empty-string-2267 "x")
(def zero-2267 0)
(def non-zero-2267 1)

(deftest test-cljs-2267
  (is (= :then (if true-2267 :then :else)))
  (is (= :else (if false-2267 :then :else)))
  (is (= :else (if nil-2267 :then :else)))
  (is (= :then (if empty-string-2267 :then :else)))
  (is (= :then (if non-empty-string-2267 :then :else)))
  (is (= :then (if zero-2267 :then :else)))
  (is (= :then (if non-zero-2267 :then :else))))

(deftest test-cljs-2403
  (are [f k coll expected] (= expected (apply f k coll))
    min-key :x [{:x 1000} {:x 1001} {:x 1002} {:x 1000 :second true}] {:x 1000 :second true}
    max-key :x [{:x 1000} {:x 999} {:x 998} {:x 1000 :second true}] {:x 1000 :second true}))

(deftest swap-vals-returns-old-value
  (let [a (atom 0)]
    (is (= [0 1] (swap-vals! a inc)))
    (is (= [1 2] (swap-vals! a inc)))
    (is (= 2 @a))))

(deftest deref-swap-arities
  (let [a (atom 0)]
    (is (= [0 1] (swap-vals! a + 1)))
    (is (= [1 3] (swap-vals! a + 1 1)))
    (is (= [3 6] (swap-vals! a + 1 1 1)))
    (is (= [6 10] (swap-vals! a + 1 1 1 1)))
    (is (= 10 @a))))

(deftest deref-reset-returns-old-value
  (let [a (atom 0)]
    (is (= [0 :b] (reset-vals! a :b)))
    (is (= [:b 45M] (reset-vals! a 45M)))
    (is (= 45M @a))))

(deftest reset-on-deref-reset-equality
  (let [a (atom :usual-value)]
    (is (= :usual-value (reset! a (first (reset-vals! a :almost-never-seen-value)))))))

(deftest test-cljs-2283
  (is (nil? (doseq []))))

(deftest test-cljs-2453
  (is (= (re-seq #"[Bc]?" "aBcD") '("" "B" "c" "" "")))
  (is (= (re-seq #"[BcD]?$" "aBcD") '("D" "")))
  (is (= (map first (re-seq #"(\d+)" "ClojureScript 1.9.222")) '("1" "9" "222")))
  (is (= (re-seq #"\d+" "a1b2c3d") '("1" "2" "3")))
  (is (= (re-seq #"\d?" "a1b2c3d") '("" "1" "" "2" "" "3" "" "")))
  (is (= (re-seq #"\d*" "a1b2c3d") '("" "1" "" "2" "" "3" "" "")))
  (is (= (re-seq #"\d+" "a1b22c333d") '("1" "22" "333")))
  (is (= (re-seq #"\d?" "a1b22c333d") '("" "1" "" "2" "2" "" "3" "3" "3" "" "")))
  (is (= (re-seq #"\d*" "a1b22c333d") '("" "1" "" "22" "" "333" "" "")))
  (is (= (re-seq #"\w+" "once upon a time") '("once" "upon" "a" "time")))
  (is (nil? (re-seq #"\w+" ""))))

(deftest test-cljs-2001
  (is (map-entry? (cljd.core/PersistentMapEntry. :key :val -1)))
  (is (not (map-entry? [:key :val]))))

(deftest test-cljs-2537
  (is (true?  (contains? (to-array [7 13 41]) -0.5)))
  (is (== 7 (get (to-array [7 13 41]) -0.5)))
  (is (== 7 (get (to-array [7 13 41]) -0.5 :not-found)))
  (is (true? (contains? "ab" -0.5)))
  (is (= \a (get "ab" -0.5)))
  (is (= \a (get "ab" -0.5 :not-found))))


(deftest test-cljs-2538
  (testing "fractional indices in nth on arrays"
    (is (thrown? RangeError (nth (to-array [1 2]) -1)))
    (is (= :not-found (nth (to-array [1 2]) -1 :not-found)))
    (is (== 1 (nth (to-array [1 2]) -0.5)))
    (is (== 1 (nth (to-array [1 2]) -0.5 :not-found)))
    (is (== 1 (nth (to-array [1 2]) 0)))
    (is (== 1 (nth (to-array [1 2]) 0 :not-found)))
    (is (== 1 (nth (to-array [1 2]) 0.5)))
    (is (== 1 (nth (to-array [1 2]) 0.5 :not-found)))
    (is (== 2 (nth (to-array [1 2]) 1)))
    (is (== 2 (nth (to-array [1 2]) 1 :not-found)))
    (is (== 2 (nth (to-array [1 2]) 1.5)))
    (is (== 2 (nth (to-array [1 2]) 1.5 :not-found)))
    (is (thrown? RangeError (nth (to-array [1 2]) 2)))
    (is (= :not-found (nth (to-array [1 2]) 2 :not-found))))
  (testing "fractional indices in nth on strings"
    (is (thrown? RangeError (nth "ab" -1)))
    (is (= :not-found (nth "ab" -1 :not-found)))
    (is (== \a (nth "ab" -0.5)))
    (is (== \a (nth "ab" -0.5 :not-found)))
    (is (== \a (nth "ab" 0)))
    (is (== \a (nth "ab" 0 :not-found)))
    (is (== \a (nth "ab" 0.5)))
    (is (== \a (nth "ab" 0.5 :not-found)))
    (is (== \b (nth "ab" 1)))
    (is (== \b (nth "ab" 1 :not-found)))
    (is (== \b (nth "ab" 1.5)))
    (is (== \b (nth "ab" 1.5 :not-found)))
    (is (thrown? RangeError (nth "ab" 2)))
    (is (= :not-found (nth "ab" 2 :not-found)))))

(defn fn-2741* ([x]) ([x y]))
(def fn-2741 fn-2741*)

(deftest test-cljs-2741
  (is (thrown? Error ((fn ([x]) ([x y])))))
  (is (thrown? Error ((fn ([x]) ([x y])) 1 2 3)))
  (is (thrown? Error (fn-2741)))
  (is (thrown? Error (fn-2741 1 2 3)))
  (is (thrown? Error ({})))
  (is (thrown? Error ({} 1 2 3))))

(deftest test-cljs-2799
  (is (thrown? Error (nth (repeat :x) -1)))
  (is (= ::not-found (nth (repeat :x) -1 ::not-found))))

(deftest uri-predicate
  (testing "Testing uri?"
    (is (not (uri? "http://clojurescript.org")))
    (is (not (uri? 42)))
    (is (not (uri? [])))
    (is (not (uri? {})))
    (is (uri? (.dataFromString Uri "http://clojurescript.org")))))

(deftest test-cljs-2832
  (is (true? ((comp not empty?) "foo")))
  (is (false? ((comp not empty?) "")))
  (is (thrown? Exception ((not empty?) "foo")))
  (is (thrown? Exception ((not empty?) ""))))

(deftest test-cljs-2864
  (is (= "" (str)))
  (is (= "a" (str "a")))
  (is (= "1" (str 1)))
  (is (= "xyzzy" (str "x" "y" "z" "z" "y")))
  (is (= "a1b2c3" (str "a" 1 "b" 2 "c" 3))))

(defn str-fn-2865 []
  "hello")

(deftest test-cljs-2865
  (is (= "ab" (str "a" (let [x true] (when x "b")))))
  (is (= "ab" (str "a" "b")))
  (is (= "ab" (str "a" nil "b")))
  (is (= "ahellob" (str "a" (str-fn-2865) "b"))))

(deftest test-cljs-2886
  (is (zero? (count "")))
  (is (== 1 (count "a")))
  (is (zero? (count #dart [])))
  (is (== 1 (count #dart [1])))
  (is (zero? (count [])))
  (is (== 1 (count [1]))))

(deftest test-cljs-2943
  ;; TODO
  (let [m1 {:a 2, :b 3, :c 5}
        m2 {:a 7, :b 11, :d 13, :e 17}
        m3 {:a 19, :d 23, :f 29}
        m4 {:a 28, :b 14, :c 5, :d 36, :e 17, :f 29}
        #_#_sorted (fn [m] (into (sorted-map) m))]
    (is (= m4 (merge-with + m1 m2 m3)))
    #_#_#_#_(is (= m4 (merge-with + (sorted m1) m2 m3)))
    (is (= m4 (merge-with + (sorted m1) (sorted m2) m3)))
    (is (= m4 (merge-with + m1 (sorted m2) m3)))
    (is (= m4 (merge-with + m1 (sorted m2) (sorted m3))))))
