(ns cljd.reader
  (:require ["dart:io" :as io]
            ["dart:async" :as async]))

(defprotocol IResolver
  (currentNS [resolver])
  (resolveClass [resolver sym])
  (resolveAlias [resolver sym])
  (resolveVar [resolver sym]))

(def ^:dynamic *resolver* nil)

(deftype ReaderInput [^#/(async/Stream String) in
                      ^:mutable ^#/(async/StreamSubscription? String) subscription
                      ^:mutable ^#/(async/Completer? String?) completer
                      ^:mutable ^String? buffer]
  (^void init_stream_subscription [this]
   (set! subscription
     (doto (.listen in
             (fn [^String s]
               (assert (nil? buffer))
               (when-not (== "" s)
                 (.complete completer s)
                 (.pause subscription))) .&
             :onDone
             (fn []
               (assert (nil? buffer))
               (.complete completer nil)
               (set! subscription nil)
               nil))
       (.pause)))
   nil)
  (^#/(async/FutureOr String?) read [this]
   (when-not (nil? subscription)
     (if-some [buf buffer]
       (do (set! buffer nil)
           (async.Future/value buf))
       (do (set! completer (async/Completer.))
           (.resume subscription)
           (.-future completer)))))
  (^void unread [this ^String s]
   (assert (nil? buffer))
   (assert (not (nil? subscription)))
   (set! buffer (when-not (== "" s) s))
   nil)
  #_(^#/(Future void) ^:async close [this]
   (when-some [sub subscription]
     (await (.cancel sub))
     (set! subscription nil)
     nil)))

(defn ^ReaderInput make-reader-input [^#/(async/StreamController String) controller]
  (doto (ReaderInput. (.-stream controller) nil nil nil) (.init_stream_subscription)))

;; read-* functions
(declare ^:async ^:dart read)

(defn ^int cu0 [^String ch] (.codeUnitAt ch 0))

(defn ^#/(Future cljd.core/PersistentList) ^:async read-list [^ReaderInput rdr]
  (let [result #dart[]]
    (loop []
      (let [val (await (read rdr (cu0 ")")))]
        (if (== val rdr)
          (-list-lit result)
          (do (.add result val)
              (recur)))))))

(defn ^#/(Future cljd.core/PersistentHashMap) ^:async read-hash-map [^ReaderInput rdr]
  (let [result #dart[]]
    (loop []
      (let [val (await (read rdr (cu0 "}")))]
        (if (== val rdr)
          (if (zero? (bit-and 1 (.-length result)))
            (-map-lit result)
            (throw (FormatException. "Map literal must contain an even number of forms")))
          (do (.add result val)
              (recur)))))))

(defn ^#/(Future cljd.core/PersistentHashSet) ^:async read-hash-set [^ReaderInput rdr]
  (let [result #dart[]]
    (loop []
      (let [val (await (read rdr (cu0 "}")))]
        (if (== val rdr)
          (set result)
          (do (.add result val)
              (recur)))))))

(defn ^#/(Future cljd.core/PersistentVector) ^:async read-vector [^ReaderInput rdr]
  (let [result #dart[]]
    (loop []
      (let [val (await (read rdr (cu0 "]")))]
        (if (== val rdr)
          (if (< 32 (.-length result))
            (vec result)
            (-vec-owning result))
          (do (.add result val)
              (recur)))))))

(def ^RegExp COMMENT-CONTENT-REGEXP #"[^\r\n]*")

(defn ^:async read-comment [^ReaderInput rdr]
  (loop []
    (if-some [s (await (.read rdr))]
      (let [index (or (some-> (.matchAsPrefix COMMENT-CONTENT-REGEXP s) .end) 0)]
        (if (< index (.-length s))
          (doto rdr (.unread (.substring s index)))
          (recur)))
      rdr)))

(defn ^:async read-regexp [^ReaderInput rdr]
  (let [sb (StringBuffer.)
        string (await (.read rdr))]
    (loop [index 0]
      (let [ch (aget string index)]
        (if (== "\"" ch)
          (do (.unread rdr (.substring string (inc index)))
              (RegExp. (.toString sb)))
          (if (< (cu0 ch) 0)
            (throw (FormatException. "EOF while reading regex"))
            (do (.write sb ch)
                (if (== "\\" ch)
                  (let [index (inc index)
                        ch (aget string index)]
                    (if (< (cu0 ch) 0)
                      (throw (FormatException. "EOF while reading regex"))
                      (do (.write sb ch)
                          (recur (inc index)))))
                  (recur (inc index))))))))))

(defn ^:async read-meta [^ReaderInput rdr]
  (let [meta (await (read rdr -1))
        meta (if (or (symbol? meta) (string? meta))
               {:tag meta}
               (if (keyword? meta)
                 {meta true}
                 (if (map? meta)
                   meta
                   (throw (FormatException. "Metadata must be Symbol,Keyword,String or Map")))))
        obj (await (read rdr -1))]
    (if (satisfies? cljd.core/IWithMeta obj)
      (with-meta obj meta)
      ;;TODO handle IReference with reset-meta
      (throw (FormatException. "Metadata can only be applied to IMetas")))))

(def ^RegExp STRING-CONTENT-REGEXP (RegExp. "(?:[^\"\\\\]|\\\\.)*"))
(def ^RegExp STRING-ESC-REGEXP (RegExp. "\\\\(?:u([0-9a-fA-F]{0,4})|([0-7]{1,3})|(.))"))

(defn ^:async read-string-content [^ReaderInput rdr]
  (let [f ^:async (fn ^String [^ReaderInput rdr]
                    (let [sb (StringBuffer.)]
                      (loop []
                        (if-some [^String string (await (.read rdr))]
                          (let [^int i (or (some-> (.matchAsPrefix STRING-CONTENT-REGEXP string) (.-end)) 0)]
                            (.write sb (.substring string 0 i))
                            (if (< i (.-length string))
                              (do (.unread rdr (.substring string (inc i)))
                                  (.toString sb))
                              (recur)))
                          (throw (FormatException. "Unexpected EOF while reading a string."))))))]
    (.replaceAllMapped (await (f rdr))
      STRING-ESC-REGEXP
      (fn [^Match m]
        (if-some [^String m1 (.group m 1)]
          (if (< (.-length m1) 4)
            (throw (FormatException. (str "Unsupported escape for character: \\u" m1 " \\u MUST be followed by 4 hexadecimal digits")))
            (String/fromCharCode (int/parse m1 .& :radix 16)))
          (if-some [^String m2 (.group m 2)]
            (String/fromCharCode (int/parse m2 .& :radix 8))
            (let [m3 (.group m 3)]
              (case m3
                "\"" (str m3)
                "\\" (str m3)
                "b" "\b"
                "n" "\n"
                "r" "\r"
                "t" "\t"
                "f" "\f"
                (throw (FormatException. (str "Unsupported escape character: \\" m3)))))))))))

(def ^:dynamic *arg-env* nil)

(declare ^:dart interpret-token ^:dart ^:async read-token ^:dart terminating?)

(defn ^:async read-arg [^ReaderInput rdr]
  ;; funny case `(let [% 1] %)` > 1
  (if (nil? *arg-env*)
    (interpret-token (await (read-token rdr "%")))
    (let [string (await (.read rdr))
          ch (cu0 (aget string 0))]
      (if (or (< ch 0) (terminating? ch))
        (let [sym (symbol "param")]
          (.unread rdr (.substring string 1))
          (set! *arg-env* (assoc *arg-env* 1 sym))
          sym)
        (if-some [^Match m (.matchAsPrefix #"(?:([\d]+)|(&))([^\d&]).*$" string)]
          (if-some [^String g3 (.group m 3)]
            (if (terminating? (cu0 g3))
              (let [g1 (.group m 1)
                    g2 (.group m 2)]
                (cond
                  g1 (let [sym (symbol (str "param" g1))]
                       (.unread rdr (.substring string (.-length g1)))
                       (set! *arg-env* (assoc *arg-env* (int/parse g1) sym))
                       sym)
                  g2 (do (.unread rdr (.substring string 1))
                         (set! *arg-env* (assoc *arg-env* -1 'parammore))
                         'parammore)))
              (throw (FormatException. "arg literal must be %, %& or %integer"))))
          (throw (FormatException. "arg literal must be %, %& or %integer")))))))

(defn ^:async read-fn [^ReaderInput rdr]
  (when-not (nil? *arg-env*)
    (throw (FormatException. "Nested #()s are not allowed")))
  (binding [*arg-env* {}]
    (let [result (await (read-list rdr))
          arg-count (cond-> (->> (keys *arg-env*) (apply max 0))
                      (*arg-env* -1) (+ 2))]
      (list 'fn*
        (list (reduce #(let [[n param] %2]
                         (if (< n 0)
                           (-> (assoc %1 (dec arg-count) param)
                             (assoc (- arg-count 2) '&))
                           (assoc %1 (dec n) param)))
                (vec (repeat arg-count '_)) *arg-env*)
          result)))))

(defn ^:async read-unquote [^ReaderInput rdr]
  (let [string (await (.read rdr))
        char (aget string 0)]
    (if (< (cu0 char) 0)
      (throw (FormatException. "EOF while reading character"))
      (if (== char "@")
        (do (.unread rdr (.substring string 1))
            (list 'cljd.core/unquote-splicing (await (read rdr -1))))
        (do (.unread rdr string)
            (list 'cljd.core/unquote (await (read rdr -1))))))))

(declare ^:dart sq-expand-list)

(defn unquote? [form]
  (and (seq? form) (= 'cljd.core/unquote (first form))))

(defn unquote-splicing? [form]
  (and (seq? form) (= 'cljd.core/unquote-splicing (first form))))

;; TODO: should not be in reader.cljd
(defn special-form? [form]
  (contains? '#{var def loop recur if case let do fn quote . deftype reify try throw catch finally new & await} form))

; TODO gensym
(defn- syntax-quote [form resolver]
  (cond
    (special-form? form) (list 'quote form)
    (symbol? form)
    (let [nsform (namespace form)
          nameform (name form)]
      (->> (cond
             (and (nil? nsform) (.endsWith nameform "#"))
             ;; TODO
             "do something"
             (and (nil? nsform) (.endsWith nameform "."))
             (let [rc (resolveClass resolver (symbol nil (.substring nameform 0 (dec (.-length nameform)))))]
               (symbol (namespace rc) (str (name rc) ".")))
             (and (nil? nsform) (== (aget nameform 0) "."))
             form
             :else
             (let [nsym (let [alias (some->> nsform (symbol nil))
                              nsym (some->> alias (resolveClass resolver))]
                          (if (nil? nsym) (resolveAlias resolver alias) nsym))]
               (if (not (nil? nsym))
                 (symbol (name nsym) nameform)
                 (if (nil? nsform)
                   (let [rsym (resolveClass resolver form)
                         rsym (if (nil? rsym) (resolveVar resolver form) rsym)]
                     (if (not (nil? rsym))
                       rsym
                       (symbol (name (currentNS resolver)) nameform)))
                   form))))
        (list 'quote)))
    (unquote? form) (second form)
    (unquote-splicing? form) (throw (FormatException. "splice not in list"))
    (number? form) form
    (string? form) form
    (keyword? form) form
    (coll? form)
    (cond
      ;; TODO records
      (vector? form)
      (list 'cljd.core/apply 'cljd.core/vector (list 'cljd.core/seq (cons 'cljd.core/concat (sq-expand-list form resolver))))
      (set? form)
      (list 'cljd.core/apply 'cljd.core/hash-set (list 'cljd.core/seq (cons 'cljd.core/concat (sq-expand-list form resolver))))
      (map? form)
      (list 'cljd.core/apply 'cljd.core/hash-map (list 'cljd.core/seq (cons 'cljd.core/concat (sq-expand-list (apply concat form) resolver))))
      (or (list? form) (seq? form))
      (list 'cljd.core/seq (cons 'cljd.core/concat (sq-expand-list form resolver)))
      :else (throw (FormatException. "Unknown Collection type")))
    :else (list 'quote form)))

(defn- sq-expand-list [s resolver]
  (map #(cond
          (unquote? %) (list 'cljd.core/list (second %))
          (unquote-splicing? %) (second %)
          :else (list 'cljd.core/list (syntax-quote % resolver))) s))

(defn ^:async read-syntax-quote [^ReaderInput rdr]
  (loop [result nil]
    (let [val (await (read rdr -1))]
      (if (== val rdr)
        result
        (recur (syntax-quote val *resolver*))))))

(def dispatch-macros
  {"_"  ^:async (fn [^ReaderInput rdr] (await (read rdr -1)) rdr)
   "^"  ^:async (fn [^ReaderInput rdr] (await (read-meta rdr)))
   "{"  ^:async (fn [^ReaderInput rdr] (await (read-hash-set rdr)))
   "("  ^:async (fn [^ReaderInput rdr] (await (read-fn rdr)))
   "!"  ^:async (fn [^ReaderInput rdr] (await (read-comment rdr)))
   "\"" ^:async (fn [^ReaderInput rdr] (await (read-regexp rdr)))
   "'"  ^:async (fn [^ReaderInput rdr] (list 'var (await (read rdr -1))))
   "<"  ^:async (fn [^ReaderInput rdr] (throw (FormatException. "Unreadable form")))})

(def macros
  {"("  ^:async (fn [^ReaderInput rdr] (await (read-list rdr)))
   ")"  ^:async (fn [_] (throw (FormatException. "EOF while reading, starting at line")))
   "{"  ^:async (fn [^ReaderInput rdr] (await (read-hash-map rdr)))
   "}"  ^:async (fn [_] (throw (FormatException. "EOF while reading, starting at line")))
   "["  ^:async (fn [^ReaderInput rdr] (await (read-vector rdr)))
   "]"  ^:async (fn [_] (throw (FormatException. "EOF while reading, starting at line")))
   "'"  ^:async (fn [^ReaderInput rdr] (list (symbol nil "quote") (await (read rdr -1))))
   "`"  ^:async (fn [^ReaderInput rdr] (await (read-syntax-quote rdr)))
   "@"  ^:async (fn [^ReaderInput rdr] (list 'cljd.core/deref (await (read rdr -1))))
   ";"  ^:async (fn [^ReaderInput rdr] (await (read-comment rdr)))
   "^"  ^:async (fn [^ReaderInput rdr] (await (read-meta rdr)))
   "\"" ^:async (fn [^ReaderInput rdr] (await (read-string-content rdr)))
   "%"  ^:async (fn [^ReaderInput rdr] (await (read-arg rdr)))
   "~"  ^:async (fn [^ReaderInput rdr] (await (read-unquote rdr)))
   "#"  ^:async (fn [^ReaderInput rdr]
                  (if-some [string (await (.read rdr))]
                    (if-some [macroreader (dispatch-macros (aget string 0))]
                      (do (.unread rdr (.substring string 1))
                          (await (macroreader rdr)))
                      (throw (FormatException. (str "Unepxected dispatch sequence: #" (aget string 0)))))
                    (throw (FormatException. "EOF while reading dispatch sequence.")))) })

(def ^RegExp SPACE-REGEXP #"[\s,]*")

(defn ^bool terminating? [^int code-unit]
  (let [ch (String/fromCharCode code-unit)]
    (cond
      (< -1 (.indexOf "'#%" ch)) false
      (macros ch) true
      (< 0 (or (some-> (.matchAsPrefix SPACE-REGEXP ch) .end) 0)) true
      :else false)))

(defn ^#/(Future String) ^:async read-token [^ReaderInput rdr ^String init]
  (let [sb (StringBuffer. init)]
    (loop [^int index 0
           ^String string ""]
      (if (== index (.-length string))
        (do (.write sb string)
            (when-some [s (await (.read rdr))]
              (recur 0 s)))
        (let [cu (.codeUnitAt string index)]
          (if (terminating? cu)
            (do (.write sb (.substring string 0 index))
                (.unread rdr (.substring string index)))
            (recur (inc index) string)))))
    (.toString sb)))


(def ^RegExp INT-REGEXP (RegExp. "([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?$"))
(def ^RegExp DOUBLE-REGEXP (RegExp. "([-+]?[0-9]+([.][0-9]*)?([eE][-+]?[0-9]+)?)(M)?$"))
(def ^RegExp SYMBOL-REGEXP (RegExp. "(?:([:]{2})|([:]))?(?:([^0-9/:].*)/)?(/|[^0-9/:][^/]*)$"))

(defn interpret-token [^String token]
  (case token
    "nil" nil
    "true" true
    "false" false
    (if-some [m (.matchAsPrefix INT-REGEXP token)]
      (let [parse (if ^some (.group m 8)
                    (if (== "-" (.group m 1))
                      (fn ^BigInt [^String s ^int radix] (- (BigInt/parse s .& :radix radix)))
                      (fn ^BigInt [^String s ^int radix] (BigInt/parse s .& :radix radix)))
                    (if (== "-" (.group m 1))
                      (fn ^int [^String s ^int radix] (- (int/parse s .& :radix radix)))
                      (fn ^int [^String s ^int radix] (int/parse s .& :radix radix))))]
        (cond
          (not (nil? (.group m 2))) 0
          (not (nil? (.group m 3))) (parse (.group m 3) 10)
          (not (nil? (.group m 4))) (parse (.group m 4) 16)
          (not (nil? (.group m 5))) (parse (.group m 5) 8)
          (not (nil? (.group m 7))) (parse (.group m 7) (int/parse ^String (.group m 6)))
          :else (throw (FormatException. (str "Invalid number: " token ".")))))
      (if-some [m (.matchAsPrefix DOUBLE-REGEXP token)]
        (if (.group m 4)
          (throw (FormatException. "BigDecimal not supported yet."))
          (double/parse token))
        (if (or (< 0 (.lastIndexOf token "::")) (.endsWith token ":"))
          (throw (FormatException. (str "Invalid token: " token)))
          (if-some [^Match m (.matchAsPrefix SYMBOL-REGEXP token)]
            (cond
              (not (nil? (.group m 1))) (throw (Exception. "TO IMPLEMENT"))
              (not (nil? (.group m 3))) (let [ns (.group m 3)]
                                          (when (.endsWith ns ":")
                                            (throw (FormatException. (str "Invalid token: " token))))
                                          (if (.group m 2)
                                            (keyword ns (.group m 4))
                                            (symbol ns (.group m 4))))
              :else (if (.group m 2)
                      (keyword nil (.group m 4))
                      (symbol nil (.group m 4))))
            (throw (FormatException. (str "Invalid token: " token)))))))))

(defn ^#/(Future dynamic) ^:async read
  [^ReaderInput rdr ^int delim]
  (loop []
    (if-some [string (await (.read rdr))]
      (let [index (or (some-> (.matchAsPrefix SPACE-REGEXP string) .end) 0)]
        (if (== index (.-length string))
          (recur)
          (let [ch (.codeUnitAt string index)]
            (if (== delim ch)
              (doto rdr (.unread (.substring string (inc index))))
              (if-some [macro-reader (macros (aget string index))]
                (do (.unread rdr (.substring string (inc index)))
                    (let [val (await (macro-reader rdr))]
                      (if (== val rdr)
                        (recur)
                        val)))
                (do (.unread rdr (.substring string index))
                    (-> (await (read-token rdr "")) interpret-token)))))))
      (if (< delim 0)
        rdr
        (throw (FormatException. (str "Unexpected EOF, expected " (String/fromCharCode delim))))))))

(defn ^#/(Future dynamic) ^:async read-string [^String s]
  (let [controller (new #/(async/StreamController String))
        rdr (make-reader-input controller)]
    (.add controller s)
    (let [res (read rdr -1)]
      (.close controller)
      (await res))))
