;   Copyright (c) Baptiste Dupuch & Christophe Grand. All rights reserved.
;   The use and distribution terms for this software are covered by the
;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;   which can be found in the file epl-v10.html at the root of this distribution.
;   By using this software in any fashion, you are agreeing to be bound by
;   the terms of this license.
;   You must not remove this notice, or any other, from this software.

;;  Tests for ClojureDart (not copied from clj/cljs code base)
;;

(ns cljd.test-clojure.core-test-cljd
  (:require ["dart:async" :as async])
  (:use [cljd.test :only [deftest is testing are]]))

(deftest testing-rseq
  (testing "Testing rseq function"
    (is (= '(4 3 2 1) (rseq [1 2 3 4])))
    (is (nil? (first (rseq []))))
    (is (= (rseq (first {:a :b})) [:b :a]))
    (is (= 9 (reduce (fn [acc x] (if (= 1 x) (reduced acc) (+ acc x))) 0 (rseq (vec (range 5))))))
    (is (= '(3 2 1) (rseq (subvec [0 1 2 3] 1))))
    (is (nil? (meta (rseq (with-meta [1] {:a :b})))))
    (is (= (meta (with-meta (rseq [1 2 3]) {:a :b})) {:a :b}))
    (is (= (rseq (vec (range 100))) (range 99 -1 -1)))))

(deftest testing-dart-literal-typehints
  (testing "#dart[] List are typehints"
    (is (dart/is? #dart[1 2] #/(List dynamic)))
    (is (dart/is? #dart ^int [1 2] #/(List int)))
    (is (dart/is? #dart ^:fixed ^int [1 2] #/(List int)))
    (let [a #dart ^int [1 2]
          b a
          c b
          d c]
      (dart/is? d #/(List int)))))

(deftest testing-if-typehints
  (testing "if typehints"
    (let [a (if (odd? 3) true false)]
      (is (dart/is? a bool)))
    (let [a (when (odd? 3) true false)]
      (is (dart/is? a bool?)))
    (let [a (if (odd? 3) 3 4)]
      (is (dart/is? a int)))
    (let [a (if (odd? 3) 3 nil)]
      (is (dart/is? a dart:core/int?)))
    (let [a (if (odd? 3) 3 4.3)]
      (is (dart/is? a dynamic)))
    (let [a (when-let [a (if (odd? 3) 3 4)] a)]
      (is (dart/is? a dart:core/int?)))
    (let [a (if (odd? 2) (throw (Exception. "exception")) "aa")]
      (is (dart/is? a String)))
    (let [a (if (odd? 2) nil nil)]
      (is (dart/is? a Null)))))

(deftest testing-loop-typehints
  (testing "loop typehints"
    (let [a (loop [i 0] (if (< i 10) (recur (inc i)) "a"))]
      (is (dart/is? a String)))
    (let [a (loop [i 0] (if (< i 10) (recur (inc i)) 1))]
      (is (dart/is? a int)))
    (let [a (loop [i 0] (if (< i 10) (recur (inc i)) ^dynamic (do 1)))]
      (is (dart/is? a dynamic)))))

(deftest testing-inline-fn-typehints
  (testing "inline fn typehints"
    (let [a (fn [] 1)]
      (is (dart/is? a #/( -> int)))) ;; int Function()
    (let [b ^:async (fn [] 1)]
      (is (dart/is? b  #/( -> (Future int)))))
    (let [c ^:async (fn [a] (if (odd? a) 3 4))]
      (is (dart/is? c #/(dynamic -> (Future int)))))
    (let [d ^:async (fn nom [a] (if (odd? a) (nom (inc a)) 4))]
      (is (dart/is? d #/(dynamic -> (Future int)))))
    (let [e ^:async (fn ^num nom [a] (if (odd? a) (nom (inc a)) 4))]
      (is (dart/is? e #/(dynamic -> (Future num)))))
    (let [f (fn ^dart:core/Never nom [] (nom))]
      (is (dart/is? f #/( -> dart:core/Never))))
    (let [g (fn nom [] (nom))]
      (is (dart/is? g #/( -> dynamic))))
    (let [h (fn [] nil)]
      (is (dart/is? h #/( -> Null))))
    (let [i ^:async (fn [] nil)]
      (is (dart/is? i #/( -> (Future Null)))))))

(deftest testing-dart-new-dont-need-to-be-lifted
  (testing "dart/new can be inlined"
    (is (dart/is?
          #dart [(dart:core/Symbol. "one") (dart:core/Symbol. "two") (dart:core/Symbol. "three")]
          #/(List Symbol)))
    (is (dart/is?
          #dart [(dart:core/Symbol. "one") (dart:core/Symbol. (let [a "a" b "b"] (str a b)))]
          #/(List Symbol)))))

(def baptiste {:first-name "Baptiste" :last-name "Dupuch"})

(deftest testing-keys-and-vals
  (is (= #{:first-name :last-name} (into #{} (keys baptiste))))
  (is (= #{"Baptiste" "Dupuch"} (into #{} (vals baptiste))))
  (is (= #{:first-name :last-name} (into #{} (keys (vec baptiste)))))
  (is (= #{"Baptiste" "Dupuch"} (into #{} (vals (vec baptiste)))))
  (is (= :a (first (keys (cons (first {:a :b}) (range 10)))))))

(deftest testing-cycle
  (is (= () (cycle nil)))
  (is (= () (cycle [])))
  (is (= '(1 2 3 1 2 3 1 2 3) (take 9 (cycle [1 2 3])))))

(deftest testing-gensym
  (is (= ":love" (namespace (gensym :love/cljd))))
  (is (= "love" (namespace (gensym 'love/cljd))))
  (is (= "love" (namespace (gensym "love/cljd")))))

(deftest testing-int-array
  (is (= (seq #dart [0 0 0]) (seq (int-array 3))))
  (is (dart/is? (int-array 3) #/(List int)))
  (is (= (seq #dart [0 1 2]) (seq (int-array (range 3)))))
  (is (dart/is? (int-array (range 3)) #/(List int)))

  (is (= (seq #dart [0 1 2 0 0]) (seq (int-array 5 (range 3)))))
  (is (dart/is? (int-array 5 (range 3)) #/(List int)))
  (is (= (seq #dart [4 4 4 4 4]) (seq (int-array 5 4))))
  (is (dart/is? (int-array 5 4) #/(List int))))

(deftest testing-amap
  (let [an-array (int-array 3 3)]
    (is (= (seq [4 4 4])
          (seq (amap an-array
                 idx
                 ret
                 (inc (aget an-array idx))))))))

;; defrecord tests

(defrecord EmptyRecord [])

(deftest testing-empty-record
  (is (= (hash (->EmptyRecord)) (hash (->EmptyRecord))))
  (is (dart/is? (-> (->EmptyRecord) (. #/(cast int int))) #/(EmptyRecord int int)))
  (is (= (for [[k v] (assoc (->EmptyRecord) :a :b :c :d :e :f)]
           k)
        '(:a :c :e))))

(defrecord RecordA [a]
  Object
  (mymethod [this] (str a "two")))

(deftest testing-recorda
  (is (= "onetwo" (.mymethod (->RecordA "one"))))
  (is (= {:a :b} (meta (with-meta (->RecordA "one") {:a :b})))))
